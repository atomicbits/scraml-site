:toc:
:linkcss:
:icons: font
:source-highlighter: pygments
:pygments-style: friendly


== Quickstart Scala

Will be added as soon as the first release of [scramlfont]#Scraml# is there (expected by the end of november 2015).


// == Writing RAML documentation

include::writing-raml.adoc[]


== Invoking Scraml

The effect of having written a RAML model becomes very cool when you start using [scramlfont]#Scraml# to generate Scala code that
brings you a typesafe and asynchronous Domain Specific Language (DSL) that will enforce you in a fluent manner to follow your RAML specs.

The sample code that we use here is based on the Scala test project for [scramlfont]#Scraml#:
https://github.com/atomicbits/scraml-test-scala. You can checkout the full codebase there and play with the RAML definition and the test
classes that showcase the DSL.

In the next sections, we first introduce the generation of case classes from json-schema followed by the integration of those typed
Data Transfer Objects (DTOs) in the [scramlfont]#Scraml# DSL. Then we go deeper into the more advanced features that [scramlfont]#Scraml#
offers.

=== Cross-referencing json-schemas

The example in <<json-user>> shows us a nested json-schema definition in which an object (an address) is defined inside the schema for a
user object. The address has a `fragment id` in this case: \#/definitions/address and it wasn't necessary to set the id explicitly
in this case because it is also deduced from its relative path inside its enclosing schema. The address object is referenced to from
the address field in the user object: `"$ref": "#/definitions/address"`.


[[json-user]]
[source,json]
.a more extensive json-schema for a user
----
{
  "$schema": "http://json-schema.org/draft-03/schema",
  "id": "http://atomicbits.io/schema/user.json#",
  "type": "object",
  "description": "A user object.",
  "definitions": {
    "address": {
      "id": "#/definitions/address",
      "type": "object",
      "properties": {
        "streetAddress": { "type": "string" },
        "city":          { "type": "string" },
        "state":         { "type": "string" }
      },
      "required": ["streetAddress", "city", "state"]
    }
  },
  "properties": {
    "id": {
      "required": true,
      "type": "string"
    },
    "firstName": {
      "required": true,
      "type": "string"
    },
    "lastName": {
      "required": true,
      "type": "string"
    },
    "age": {
      "required": true,
      "type": "integer"
    },
    "homePage": {
      "required": false,
      "$ref": "link.json"
    },
    "address": {
      "$ref": "#/definitions/address"
    }
  }
}
----


A more common approach to refer to another object is defining the object in another schema file and refer to its absolute `id`.
The `homePage` field of the user object refers to `"$ref": "link.json"`. This reference is an relative reference and it is completed
by the anchor of the id of the enclosing user schema: `http://atomicbits.io/schema/`, so the full reference becomes:
`http://atomicbits.io/schema/link.json`. So there must be another json-schema file included in the RAML model that has exactly this id.
Mind the different approaches to define the required fields in the address object versus the user object. Both approaches are properly
interpreted by [scramlfont]#Scraml# (see further for the different handling of required versus non-required fields).

The <<json-link>> object and the <<json-method>> complete the user object and the objects it refers to.

[[json-link]]
[source,json]
.link object
----
{
  "$schema": "http://json-schema.org/draft-03/schema",
  "id": "http://atomicbits.io/schema/link.json#",
  "type": "object",
  "description": "A href",
  "properties": {
    "href": {
      "type": "string",
      "required": true
    },
    "method": {
      "required": true,
      "$ref": "method.json"
    },
    "accept": {
      "type": "string",
      "required": false
    }
  }
}
----


[[json-method]]
[source,json]
.method enumeration
----
{
  "$schema": "http://json-schema.org/draft-03/schema",
  "id": "http://atomicbits.io/schema/method.json#",
  "enum": [ "GET", "PUT", "POST", "DELETE", "HEAD", "CONNECT", "TRACE", "OPTIONS" ]
}
----


Now, let's see how the generated case classes look like.



=== Generated case classes

The <<scala-user>> reflects the fields described by the corresponding json-schema. Notice that the types of the fields that were not
required (such as homePage) are wrapped in the `Option` monad. The address object has a strange canonical name that is a result of the
somewhat unconventional `id` that we gave in the nested json-schema example. All optional fields have a default value of `None`, which
shortens the construction of those case classes when the values of those fields are empty. The <<scala-link>> is referred to by the User
object (the `homePage` field). Because both classes are in the same package, the import statement to the Link class in User is omitted.

[[scala-user]]
[source,scala]
.User case class
----
package io.atomicbits.schema

import play.api.libs.json._

case class User(age: Long,
                lastName: String,
                firstName: String,
                id: String,
                homePage: Option[Link] = None,
                address: Option[UserDefinitionsAddress] = None)

object User {

  implicit val jsonFormatter: Format[User] = Json.format[User]

}
----

JSON serialization is done with play-json 2.4, hence the dependency on `play.api.libs.json._` (together with ning our only external
dependencies to use the DSL). The formatters are defined in the companion objects.

[[scala-link]]
[source,scala]
.Link case class
----
package io.atomicbits.schema

import play.api.libs.json._

case class Link(href: String,
                method: Method,
                accept: Option[String] = None)

object Link {

  implicit val jsonFormatter: Format[Link] = Json.format[Link]

}
----


Enumerations like the <<scala-method>> are implemented as a sealed trait with a name field and case objects for each choice in its
companion object. JSON serialization goes directly to the name of the choice as a string without wrapper object.

[[scala-method]]
[source,scala]
.Method enumeration
----
package io.atomicbits.schema

import play.api.libs.json.{Format, Json, JsResult, JsValue, JsString}

sealed trait Method {
  def name: String
}

object Method {

  case object GET extends Method {
    val name = "GET"
  }

  case object PUT extends Method {
    val name = "PUT"
  }

  case object POST extends Method {
    val name = "POST"
  }

  case object DELETE extends Method {
    val name = "DELETE"
  }

  case object HEAD extends Method {
    val name = "HEAD"
  }

  case object CONNECT extends Method {
    val name = "CONNECT"
  }

  case object TRACE extends Method {
    val name = "TRACE"
  }

  case object OPTIONS extends Method {
    val name = "OPTIONS"
  }

  val byName = Map(
    GET.name → GET, PUT.name → PUT, POST.name → POST, DELETE.name → DELETE, HEAD.name → HEAD, CONNECT.name → CONNECT, TRACE.name → TRACE, OPTIONS.name → OPTIONS
  )

  implicit val MethodFormat = new Format[Method] {

    override def reads(json: JsValue): JsResult[Method] = {
      json.validate[String].map(Method.byName(_))
    }

    override def writes(o: Method): JsValue = {
      JsString(o.name)
    }
  }
}

----

=== Scraml typesafe asynchronous DSL

Now that we have a feeling of how the DTOs look like, we can start to explain how [scramlfont]#Scraml# turns the RAML resource definitions
into a typesafe DSL. Below, a <<raml-userservice>> is modeled in RAML using the json-schema definition of `user.json`, `link.json` and
`method.json` that we introduced before.

We defined a `/rest/user/' resource with a `GET` action on it that takes several query parameters. Notice that one of the query parameters
has a `repeat: true` definition on it. We'll see in a minute how that translates into the DSL. The result body is of type `application/json`
and more concrete an array of User objects. Here the json-schema definition is defined inline. Mind that the `id` is currently still
necessary on inline schemas even if they aren't an unique object definion. In a future release, `id` fields will not be mandatory on inline
schemas.

Next, we have a `multipart/form-data` POST action on `/rest/user/upload` and a resource that takes URL-parameters: `/rest/user/{userid}`.
The `userid` URL-parameter is defined as a string and [scramlfont]#Scraml# will enforce this. There is a form-POST action on
this resource with a required and a non-required form field. The response will have a JSON format, but it is not defined which schema it
follows. This will imply that we don't have type information in the DSL on that response. Finally, we have a DELETE action and a
POST action that sends a User and receives a Link.


[[raml-userservice]]
[source,yaml]
.user service
----
#%RAML 0.8
---
title: My api 
version: v1

schemas:
  - link:         !include schemas/link.json
  - method:       !include schemas/method.json
  - user:         !include schemas/user.json

/rest/user/:
  get:
    queryParameters:
      age:
        description: The age of the user.
        type: number
      firstName:
        description: The firstname of the user.
        type: string
      lastName:
        description: The last name of the user.
        type: string
      organization:
        description: The organization of the user.
        type: string
        repeat: true
    responses:
      200:
        body:
          application/json:
            schema: |
              {
                "id": "http://atomicbits.io/schema/anonymous1.json",
                "type": "array",
                "items": {
                  "$ref": "user.json"
                }
              }


/rest/user/upload:
  post:
    body:
      multipart/form-data:
    responses:
      200:
        body:

/rest/user/{userid}:
  uriParameters:
    userid:
      description: The user's id.
      type: string
      required: true
  post:
    body:
      application/x-www-form-urlencoded:
        formParameters:
          text:
            description: Text to post as a comment on the user.
            type: string
            required: true
          value:
            description: Value to give to a user.
            type: integer
            required: false
    responses:
      200:
        body:
  delete:
  put:
    body:
      application/json:
        schema: user
    responses:
      200:
        body:
          application/json:
            schema: link

----

Compiling the codebase using sbt, [scramlfont]#Scraml# will generate the DSL in the code generation step before actual compilation. This
results in a client that provides access to the resources we described above. Let's assume the above RAML file sits in the folder
`io/atomicbits/api/` under the resources folder and the filename is `user-api.raml`. The resulting DSL can be used to do the following.


[[scala-client]]
[source,scala]
.client DSL code
----
  import io.atomicbits.api.UserApi
  ...
  val client = new UserApi(
    host = "somehost",
    port = 80,
    protocol = "http",
    defaultHeaders = Map("Accept" -> "application/json"),
    prefix = None,
    config = ClientConfig()
  )

  val userResource = client.rest.user
  val userFoobarResource = userResource.userid("foobar")

  val eventualUserResponse: Future[List[User]] =
    userResource
      .get(
        age = Some(51),
        firstName = Some("John"),
        lastName = None,
        organization = List("ESA", "NASA")
      )
      .asType

  val userResponse: List[User] = Await.result(eventualUserResponse, 2 seconds)
----

The `UserApi`